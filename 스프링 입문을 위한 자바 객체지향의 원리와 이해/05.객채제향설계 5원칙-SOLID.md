# 객체 지향 설계 5원칙 - SOLID
* 객체 지향 설계(OOD; Object Oriented Design)
  * 로버트 C. 마틴이 2000년대 초반 객체지향 프로그래밍 및 설계의 기본원칙으로 제시
  * 마이클 페더스가 두문자어로 소개함
  * **"응집도는 높이고(High Cohesion), 결합도는 낮추라(Loose Coupling)"** 는 고전 원칙을 객체지향의 관점에서 재정립한 것

### 결합도와 응집도
* 결합도
  * 모듈(클래스)간 상호의존 정도
  * 결합도가 낮으면 모듈간 상호 의존성이 줄어들어 객체의 재사용, 수정, 유지보수 용이
  * 결합도 수준
    * 데이터 결합도, 스탬프 결합도, 컨트롤 결합도, 외부 결합도, 공유 결합도, 내용 결합도
* 응집도
  * 하나의 모듈(클래스) 내부에 존재하는 구성요소들의 기능적 관련성
  * 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아짐 -> 객체의 재사용, 수정, 유지보수 용이
  * 응집도 수준
    * 기능 응집도, 순차 응집도, 통신 응집도, 절차 응집도, 시간 응집도, 논리 응집도, 우연 응집도

### SoC (Seperation Of Concerns, 관심사의 분리)
* 관심이 같은 것끼리 하나의 객체 안으로 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 따로 떨어져 서로 영향을 주지 않도록 분리함
* 하나의 속성, 하나의 메서드, 하나의 클래스, 하나의 모듈, 하나의 패키지에는 하나의 관심사만 들어가 있어야 함
* 관심사가 다르고 변화의 시기가 다르면 분리해야 함
* SoC를 적용하면 자연스럽게 SRP, ISP, OCP에 도달함
* 스프링은 SoC를 통해 SOLID를 극한까지 적용함

### SOLID
* SOLID는 OOP를 구성하는 속성, 메서드, 클래스, 객체, 패키지, 모듈, 라이브러리, 프레임워크, 아키텍처 등 다양한 곳에 다양하게 적용되는 것
* SOLID는 '제품'이 아닌 **'개념'** 이다.
* SOLID를 잘 적용한 소프트웨어는 그렇지 않은 소프트웨어에 비해 이해하기 쉽고, 리팩터링 및 유지보수가 수월하며 논리적으로 정연하다.
* SOLID는 객체지향의 4대 특성(캡슐화, 상속, 다형성, 추상화)을 기반으로 한다.
* SOLID는 디자인패턴의 뼈대이자 스프링 프레임워크의 근간이다.
* SOLID를 적용하면 소스파일의 개수는 더 많아지는 경향이 있다. --> 그러나 유지보수 및 관리가 쉬운 코드가 만들어진다.
* SOLID는 OCP가 현실세계같아야 한다는 요건보다는, 추상화됐다는 두번째 요건에 초점을 맞춤

## SRP (Single Responsibility Principle, 단일 책임 원칙)
> "어떤 클래스를 변경해야 하는 이유는, 오직 하나 뿐이어야 한다." - 로버트 c.마틴
* 역할(책임)을 분리
  * 속성, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크 등에 적용 가능
  * 모델링 과정을 담당하는 <U>추상화</U> 와 관련 깊은 원칙

### SRP를 지키지 못한 예시

#### 클래스가 SRP를 지키지 못한 경우
* 예) '남자'클래스가 '남자친구', '아들', '사원', '소대원'의 역할과 기능을 모두 맡도록 함 
  * --> SRP) 남자'클래스를 분리하여 '남자친구'클래스, '아들'클래스, '사원'클래스, '소대원'클래스로 쪼갬. '남자'클래스와 '여자'클래스의 공통점이 있다면 '사람'클래스에 공통점을 두고 '남자'클래스와 '여자'클래스는 '사람'을 상속받게 하여 차이점만 구현함.

#### 속성이 SRP을 지키지 못한 경우
* 예) 데이터베이스 테이블에 존재하는 하나의 필드가 '토지'인 경우 '면적'을, '건물'인 경우 '층수'를 나타내게 함(하나의 속성이 여러 의미를 가짐, 자바 코드에서 if문을 여기저기 사용해야만 함)
  * ---> SRP) 테이블 설계시에도 '정규화'라는 과정을 거쳐 SRP를 고려해야 함

#### 메서드가 SRP를 지키지 못한 경우
* 예) 하나의 메서드가 여러 기능을 처리하하기 위하여 분기 처리 if를 진행함

## OCP (Open Closed Principle, 개방 폐쇄 원칙)
> "소프트웨어 엔티티(클래스, 모듈, 함수 등)은 (자신의)확장에 대해 열려 있어야 하지만, (외부의)변경에 대해서는 닫혀 있어야 한다." - 로버트 C. 마틴

### OCP를 지키지 못한 예시
* 예1) 운전자가 '마티즈'를 운전할 때와 '쏘나타'를 운전할 때 운전에 영향을 받아야만 함
  * --> OCP) 운전자와 구체적인 차종 모델 사이에 '자동차'라는 상위클래스 혹은 인터페이스를 둠으로써, 설사 다양한 자동차로 변경된다고 해도 운전자는 운전 습관에 영향을 받지 않게 함
    * 자동차의 입장에서는 자신의 확장에('마티즈', '쏘나타', ...)에 개방돼있는 것이고, 운전자 입장에서는 주변의 변화에 폐쇄되어 있는 것

### OCP를 적용한 예시

#### OCP 적용 예1) JDBC
* JDBC를 사용하는 클라이언트는 데이터베이스가 오라클에서 MySQL로 변경되어도 Connection을 설정하는 부분 외에는 따로 수정할 필요가 없음
* Connection 설정 부분을 별도의 설정파일로 분리해두면 클라이언트 코드는 단 한줄도 변경이 불필요함
* JDBC를 사용할 때 자바 애플리케이션은 DB라는 주변의 변화에 닫혀있고, 데이터베이스 입장에서는 자신의 확장(오라클, MySQL...)에 열려 있음

#### OCP 적용 예2) JVM
* 자바는 각 운영체제별 JVM과 목적파일(.class)이 있음
* 따라서 개발자는 다양한 구동환경에 대해 걱정하지 않고 본인이 작업하고있는 PC에 설치된 JVM에서 구동되는 코드만 작성하면 됨
* 개발자가 작성한 소스코드는 운영체제의 변화에 닫혀있고, 각 운영체제별 JVM은 확장에 열려있음
* 소스코드와 운영체제별 JVM 사이에 목적파일(.class)이라는 완충장치가 있는 것

#### OCP 적용 예3) 자바의 각종 상속구조

#### OCP 적용 현실 사례) 고객과 판매 인터페이스와 여러 직원
* 직원이 바뀐다고 해도 손님이 구매라는 행위를 하는데 영향 없음
* 직원 교대라는 주변의 변화에 대해 손님은 닫혀있고, 직원은 교대라는 확장 행위에 열려 있음

## LSP (Liskov Substitution Principle, 리스코프 치환 원칙)
> "서브타입은 언제나 자신의 기반 타입(Base type)으로 교체할 수 있어야 한다. - 로버트 C. 마틴"
* 객체지향의 상속 특성을 올바르게 활용하면 자연스럽게 얻게 되는 것
* 상속은 '조직도, 계층도'가 아니라 <u>분류도</u>로 이해되어야 한다.
  * 하위 클래스 is a kind of 상위 클래스(하위분류는 상위분류의 한 종류다.)
  * 구현 클래스 is able to 인터페이스(구현분류는 인터페이스할 수 있어야 한다.)

* 클래스간 아버지-딸 구조(계층도/조직도)는 리스코프 치환 원칙을 위배함
* 클래스간 동물-펭귄 구조(분류도)는 리스코프 치환 원칙을 만족함

> 하위 클래스의 인스턴스는 상위형 객체의 참조변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.

## ISP (Interface Segregation Principle, 인터페이스 분리 원칙)
> "클라이언트는 자신이 사용하지 않는 메서드에 의존관계를 맺으면 안된다. -로버트 C. 마틴"

* ISP와 SRP는 같은 문제에 대한 두 가지 다른 해결책이다.
  * 예) '남자'클래스가 '남자친구', '아들', '사원', '소대원'의 역할과 기능을 모두 맡도록 함
    * --> ISP) '남자' 클래스와 '여자친구'클래스 사이에 '남자친구'라는 인터페이스르 둠, '남자'클래스와 '어머니'클래스 사이에 '아들'이라는 인터페이스를 둠...
  * 특별한 경우가 아니면 SRP를 적용하는 것이 더 좋은 해결책이다.

* 인터페이스 최소주의 원칙
  * 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공해야 함
  * 상위 클래스는 풍성할수록 좋고, 인터페이스는 작을수록 좋다.
    * 풍성한 상위클래스를 이용할 때 불필요한 형변환이 없음.

## DIP (Dependency Inversion Principle, 의존 역전 원칙)
> "고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다."
>
> "추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상회된 것에 의존해야 한다."
> 
> "자주 변경되는 구체(Concrete)클래스에 의존하지 마라." - 로버트 C. 마틴

* 상위 클래스일수록, 인터페이스일수록, 추상클래스일수록 변하지 않을 가능성이 높다.
* 구체 클래스가 아니라 추상화된 인터페이스나 상위 클래스에 의존해야한다. 그래야 변하기 쉬운 것의 변화에 영향을 받지 않을 수 있기 때문이다.

* DIP 적용의 예시
  * 예1) 자동차는 '스노우타이어', '일반타이어', '광폭타이어' 등 자주 변경되는 구체 클래스에 의존하지 않고, 타이어 인터페이스를 의존하게 해야 한다.
  * 예2) JDBC
 