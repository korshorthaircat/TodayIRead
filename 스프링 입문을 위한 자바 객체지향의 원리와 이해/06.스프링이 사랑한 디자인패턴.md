# 스프링이 사랑한 디자인패턴
* 디자인패턴
  * 실제 개발현장에서 비즈니스 요구사항을 프로그래밍으로 처리하며 만들어진 다양한 해결책 중 베스트 프랙티스를 정리한 것
  * 객체지향의 특성(상속, 인터페이스, 합성-객체를 속성으로 사용)과 설계원칙SOLID를 기반으로 구현됨
* 스프링 프레임워크
  * 공식적 정의
    * 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크
  * 객체지향의 특성과 설계원칙을 극한까지 적용한 프레임워크
  * 객체지향의 설계의 베스트 프랙티스(디자인패턴) 적용됨

## 어댑터 패턴 (Adapter Pattern)
>객체를 속성으로 만들어 참조하는 디자인패턴

>호출당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하드록 중간에 변환기(Adapter)를 통해 호출하는 패턴
* 어댑터, 변환기(converter) - 서로 다른 두 인터페이스 사이에 통신이 가능하게 함
### 어댑터 패턴은 개방폐쇄원칙(OCP)를 활용한 설계 패턴이다
* 예1) 다양한 데이터베이스 시스템을 공통의 인터페이스인 ODBC 또는 JDBC를 이용해 조직함
  * ODBC/JDBC는 어댑터 패턴을 이용해 다양한 DB 시스템을 단일한 인터페이스로 조작할 수 있게 해줌
  * JDBC가 어댑터 역할 수행
* 예2) 플랫폼별 JRE
  * JRE가 어댑터 역할 수행 

## 프록시 패턴 (Proxy Pattern)
> 제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 디자인패턴

> * 대리자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이 때 인터페이스를 사용한다.
> * 대리자는 실제 서비스에 대한 참조변수를 갖는다.(합성)
> * 대리자는 실제 서비스와 같은 이름을 가진 메서드를 호출하고 그 값을 클라이언트에게 돌려준다.
> * 대리자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수 있다. 

* 프록시 - 대리자, 대변인
* 서비스 객체가 가진 메서드와 같은 이름의 메서드를 사용, 이를 위해 인터페이스를 사용
* 서비스 객체가 들어갈 자리에 대리자 객체를 대신 투입
* 클라이언트쪽에서는 실제 서비스 객첼르 통해 메서드를 호출하고 반환값을 받는지, 대리자 객체를 통해 메서드를 호출하고 반환값을 받는지 전혀 모르게 처리

### 프록시 패턴은 개방폐쇄원칙(OCP), 의존역전원칙(DIP)를 활용한 설계 패턴이다

## 데코레이터 패턴 (Decorator Pattern)
> 메서드 호출의 반환값에 변화를 주기 위해 중간에 장식자를 두는 디자인 패턴

> * 장식자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이ㄷ때 인터페이스를 사용한다.
> * 장식자는 실제 서비스에 대한 참조 변수를 갖는다(합성).
> * 장식자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고, 그 반환값에 장식을 더해 클라이언트에게 돌려준다.
> * 장식자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수도 있다.

* 데코레이터 - 도장/도배업자
* 프록시패턴과 구현방법이 같음
  * 프록시 패턴은 클라이언트가 최종적으로 돌려받는 반환값을 특별한 경우가 아니면 조작하지 않고 그대로 전달
  * 데코레이터 패턴은 클라이언트가 받는 반환값에 장식을 더함

## 싱글턴 패턴 (Singleton Pattern)
> 클래스의 인스턴스, 즉 객체를 하나만 만들어 사용하기 위한 디자인 패턴

> * new를 실행할 수 없도록 **생성자에 private 접근 제어자** 를 갖는다.
> * 유일한 단일 객체를 반환할 수 있는 **정적메서드** 가 필요하다. getInstance()
> * 유일한 단일 객체를 참조할 수 있는 **정적 참조 변수** 가 필요하다.
> * 단일객체는 쓰기 가능한 속성을 갖지 않는 것이 정석이다

* 커넥션풀, 스레드풀, 디바이스설정객체 등과 같은 경우 인스턴스를 여러 개 만들게 되면 불필요한 자원을 사용하게 되고, 또 프로그램이 예상치 못한 결과를 낳을 수 있음
* 싱글턴패턴은 인스턴스를 오직 하나만 만들고 그것을 계속해 재사용함
  * 의미상 두 개의 객체가 존재할 수 없음
  * 객체 생성을 위한 new에 제약을 걸어야 하고, 만들어진 단일객첼르 반환할 수 있는 메서드가 필요함
  * 단일 객체인 경우 결국 공유객체로 사용되기 때문에 속성을 갖지 않게 하는 것이 정석임
    * 단, 읽기전용 속성을 갖는것은 문제가 되지 않음, 단일 객체가 다른 단일 객체에 대한 참조를 속성으로 갖는것도 문제가 되지 않음(스프링 싱글턴 빈이 가져야 할 제약조건)

## 템플릿 메서드 패턴 (Template Method Pattern)
> 상위 클래스의 견본 메서드에서 하위 클래스가 오버라이딩한 메서드를 호출하는 디자인 패턴

> * 템플릿 메서드 패턴의 구성 요소
>   * 템플릿 메서드
>     * 공통 로직을 수행, 로직 중 하위 클래스에서 오버라이딩한 추상 메서드/훅 메서드를 호출
>   * 추상 메서드
>     * 템플릿메서드에서 호출함. 하위클래스가 반드시 오버라이딩해야 함.
>   * 훅 메서드
>     * 템플릿메서드에서 호출함. 하위클래스가 선택적으로 오버라이딩 함.
### 템플릿 메서드 패턴은 의존역전원칙(DIP)를 활용한 설계 패턴이다

## 팩토리 메서드 패턴 (Factory Method Pattern)
> 하위 클래스에서 팩터리 메서드를 오버라이딩해서 객체르 반환하게 하는 디자인 패턴

> 오버라이드된 메서드가 객체를 반환하는 디자인 패턴

* 팩토리 - 공장, 객체를 생성함
  * 팩토리 메서드 - 객체를 생성 반환하는 메서드
### 팩터리 메서드 패턴은 의존역전원칙(DIP)을 활용한 설계 패턴이다

## <mark>전략 패턴 (Strategy Pattern)</mark>
> 클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 디자인 패턴

> * 전략 패턴을 구성하는 세 요소
>   * 전략 객체 - 전략 메서드를 가짐
>   * 컨텍스트(전략 객체의 사용자, 소비자)
>   * 클라이언트(제 3자, 전략 객체의 공급자) - 전략객체를 생성해 컨텍스트에 주입

* 전략 패턴은 디자인 패턴에서 매우 중요 - 다양한 문제 상황의 해결책으로 사용됨
* 클라이언트는 다양한 전략 중 하나를 선택해 생성한 후 컨텍스트에 주입함
  * 전략을 다양하게 변경하면서 컨텍스트를 실행할 수 있음
* 템플릿(견본) 메서드 패턴과 유사함
  * 같은 문제의 해결책으로써 템플릿 메서드 패턴은 상속을 사용하고
  * 전략패턴은 객체 주입 방식을 택함
  * 단일 상속만 가능한 자바에서는 상속이라는 제한이 있는 템플릿 메서드 패턴보다 전략 패턴이 더 많이 활용됨

### 전략 패턴은 개방폐쇄원칙(OCP)와 의존역전원칙(DIP)을 활용한 설계 패턴이다

## <mark>템플릿 콜백 패턴 (Template Callback Pattern - 견본/회신 패턴)</mark>
> 전략을 익명 내부 클래스로 구현한 전략 디자인 패턴

* 전략 패턴의 변형
  * 스프링 3대 프로그래밍 모델 중 하나인 DI(의존성 주입)에서 사용하는 특별한 형태의 전략 패턴
  * 전략 패턴과 동일하지만, 전략을 익명 내부 클래스로 정의해 사용한다는 특징이 있음
  * 중복되는 부분을 컨텍스트로 이관하여 클라이언트 코드가 상당히 깔끔해짐

### 템플릿 콜백 패턴은 전략패턴의 일종이므로, 개방폐쇄원칙(OCP)와 의존역전원칙(DIP)을 활용한 설계 패턴이다
