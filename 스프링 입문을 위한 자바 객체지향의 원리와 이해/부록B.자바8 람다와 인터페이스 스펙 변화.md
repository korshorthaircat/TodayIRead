# 부록B. 자바8 람다와 인터페이스 스펙 변화

## 1. 람다가 도입된 이유
* 배경 - 빅데이터의 대두(가장 주된 이유)
  * 기업 환경 변화
    * 빅데이터
      * 기업들은 빅데이터의 분석 및 활용을 통해 기업전략을 수립하고 수익 극대화하고자 함
      * 빅데이터 분석은 ICT기술을 통해 이뤄질 수 밖에 없음
    * 프로그래머들의 요구
      * 빅데이터를 프로그램적으로 다룰 수 있는 방법이 필요해짐
        * 멀티코어를 활용한 분산 처리, 즉 병렬화 기술이 필요함
        * 멀티 코어프로세서(하나의 CPU안에 다수의 코어를 삽입)들의 등장으로 인해 일반 프로그래머에게도 병렬화 프로그래밍에 대한 필요성이 생겨남

* 변화하는 외부 상황에 대한 자바의 대응 <mark><자바8></mark>
  * 병렬화 프로그래밍에 대한 필요성 
  * --> **컬렉션**(배열, List, Set, Map)의 강화
  * --> **스트림**(Stream) 강화
  * --> **함수형 프로그래밍, 람다** 도입
  * --> **인터페이스 명세 변경**
  * --> **함수형 인터페이스** 도입

## 2. 람다란 무엇인가?
* 람다
  * 람다 이전의 상황
    * 기존의 코드블록은 반드시 메서드 내부에 존재해야 함. 코드블록을 위해 메서드를, 다시 메서드를 사용하기 위해 익명객체가 필요했음
    * 로직은 메서드를 통해서만 구현 가능했음.
  * 람다 = 변수에 저장 가능한 로직   
      * 변수는 지역변수, 속성, 메서드의 인자, 메서드의 반환값으로 사용할 수 있음
      * 그러므로 람다도 지역변수, 속성, 메서드의 인자, 메서드의 반환값으로 사용할 수 있음
      * 로직을 람다로 표현할 수 있게 되면서, 람다게 메서드의 역할을 하게 됨.
        * 더 이상 로직을 메서드의 체계, 즉 인스턴스 메서드나 스테이틱 메서드 안에 구현하지 않아도 됨.

## 3. 함수형 인터페이스
* 함수형 인터페이스
  * 추상메서드를 하나만 갖는 인터페이스
  * 예)
    * Runnable 인터페이스는 run()이라는 하나의 추상메서드만 가지므로 함수형 인터페이스이다.
  * 함수형 인터페이스만을 람다식으로 변경할 수 있다.
  * 함수형 인터페이스를 직접 선언할 수 있다.

## 4. 메서드 호출 인자로 람다 사용
  * 람다식을 변수에 저장할 수 있다면, 당연히 메서드의 인자로도 사용할 수 있다.
  * 람다식을 단 한번만 사용한다면 굳이 변수에 할당할 필요도 없다.

## 5. 메서드 반환값으로 람다 사용
  * 람다식을 메서드의 반환값으로 사용할 수 있다.

## 6. 자바8 API에서 제공하는 함수형 인터페이스
  * 사용자정의형 함수형인터페이스를 만들어 사용하는 것도 가능하지만,
  * java.util.function에서 제공하는 함수형 인터페이스를 쓰는것이 권장된다.
    * [자바8 API에서 제공하는 대표적인 함수형 인터페이스](https://github.com/korshorthaircat/practice/blob/main/src/main/java/_202212/Java8FunctionalInterfaceTest.java)

## 7. 컬렉션 스트림에서 람다 사용
* 스트림의 장점
  * 스트림은 고객의 요구를 선언적으로 코딩할 수 있게 한다.
  * 스트림은 컬렉션 스트림을 다른 스트림으로 변환하는 map, 집계 함수인 sum, count, average, min, max뿐 아니라 특정 기준에 의한 그룹화(grouping) 지원 등 많은 메서드를 제공함
  * [예) 컬렉션 스트림 이용](https://github.com/korshorthaircat/practice/blob/main/src/main/java/_202212/Stream001.java)
  * [스트림에서 제공하는 메서드](https://github.com/korshorthaircat/practice/blob/main/src/main/java/_202212/Stream002.java)

## 8. 메서드 레퍼런스와 생성자 레퍼런스
### 메서드 레퍼런스
* 메서드 레퍼런스 표기법
  * 인스턴스::인스턴스메서드
    * 람자식의 인자는 인스턴스메서드의 인자가 된다.
    * 예) System.out::println
      * num -> System.out.println(num)
  * 클래스::정적메서드
    * 람다식의 인자는 정적메서드의 인자가 된다.
    * 예) Math:sqrt
      * num -> Math.squr(num)
  * 클래스::인스턴스메서드
    * 첫번째 인자는 인스턴스가 되고, 그다음 인자(들)은 인스턴스 메서드의 인자(들)이 된다.
    * 예) Integer::compareTo
      * (a, b) -> a.compareTo(b)
* [예) 메서드 레퍼런스의 사용](https://github.com/korshorthaircat/practice/blob/main/src/main/java/_202212/MethodReference001.java)
    
### 생성자 레퍼런스
* 생성자 레퍼런스 표기법
  * 클래스::new
* * [예) 생성자 레퍼런스의 사용](https://github.com/korshorthaircat/practice/blob/main/src/main/java/_202212/MethodReference002.java)

## 9. 인터페이스의 디폴트 메서드와 정적 메서드

## 10. 정리