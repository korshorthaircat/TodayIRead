# 1.1 디자인 패턴
- 디자인 패턴
    - 프로그램을 설계할 때 발생했던 문제점들을 객체간 상호관계 등을 이용해 해결할 수 있도록 하나의 ‘규약’ 형태로 만들어 놓은 것

## 1.1.1 싱글톤 패턴

- 싱글톤 패턴
    - 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
- 많이 쓰이는 예
    - **데이터베이스 연결 모듈**
- 장점
    - 하나의 인스턴스를 다른 모듈들이 공유해 사용하므로, 인스턴스를 생성할 때 드는 비용이 줄어듬
- 단점
    - 의존성이 높아짐
        - 모듈 간의 결합이 강해짐
        - 따라서 DI(의존성 주입)을 통해 모듈간 결합을 조금 더 느슨하게 만들 필요가 있음
    - TDD(Test Driven Development)를 할 때 방해됨
        - TDD를 할 때, 단위 테스트를 주로 하는데 단위 테스트는 테스트가 서로 독립적이어야하고, 테스트를 어떤 순서로든 실행할 수 있어야 함
        - 그러나 싱글톤 패턴은 각 테스트마다 ‘독립적인’ 인스턴스를 만들기 어려움

### ✔️ 자바스크립트에서의 싱글톤 패턴

- 자바스크립트에서는 리터럴{} 또는 new Object로 객체를 생성하면 다른 어떤 객체와도 같지 않음 → 이 자체 만으로 싱글톤 패턴 구현 가능

### ✔️ 자바에서의 싱글톤 패턴

### ✔️ 자바스크립트에서의 싱글톤 패턴

### ✔️ MySQL의 싱글톤 패턴

### ✔️ mongoose의 싱글톤 패턴

- Node.js에서 MongoDB를 연결할 때 쓰는 mongoose모듈에서 싱글톤 패턴을 볼 수 있음.
    - mongoose의 디비 연결에 쓰이는 connect()라는 함수가 싱글톤 인스턴스를 반환함

## 의존성 주입(DI, Dependency Injection)

- 의존성(종속성)
    - 'A가 B에 의존성이 있다' = B의 변경사항에 대해 A 또한 변해야 된다
- 의존성 주입
    - 메인 모듈이 ‘직접’ 다른 하위 모듈에 대한 의존성을 주기 보다는, 중간에 의존성 주입자(dependency injector)가 이 부분을 가로채 메인 모듈이 ‘간접’적으로 의존성을 주입하는 방식
    - 이를 통해 메인 모듈(상위 모듈)은 하위 모듈에 대한 의존성이 떨어지게 됨(디커플링)
- 의존성 주입의 원칙
    - “상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 한다. 또한 둘 다 추상화에 의존해야 하며, 이 때 추상화는 세부사항에 의존하지 말아야 한다.”
- 의존성 주입의 장점
    - 모듈을 쉽게 교체할 수 있는 구조가 됨
        - → 테스팅하기 쉬움
        - → 마이그레이션도 수월
    - 구현할 때 추상화 레이어를 넣고 이를 기반으로 구현체 넣어줌
        - → 애플리케이션 의존성 방향이 일관됨
        - → 애플리케이션 쉽게 추론 가능
        - → 모듈간 관계가 명확해짐
- 의존성 주입의 단점
    - 모듈이 더욱 분리되므로 클래스 수가 늘어자 복잡성 증가될 수 있음
    - 약간의 런타임 페널티

## 1.1.2 팩토리 패턴

- 팩토리 패턴
    - 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴
    - 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정, 하위 클래스에서는 객체 생성에 대한 구체적 내용을 결정
- 특징
    - 느슨한 결합, 유연성
    - 유지 보수성 증가( ← 객체 생성 로직이 따로 뗴어져 있으므로, 코드 리팩터링 시에 한 곳만 고쳐도 됨)
- 예)
  - 하위클래스에는 라떼 레시피, 아메리카노 레시피, 우유 레시피라는 구체적인 내용이 들어있고, 이것이 컨베이어벨트를 통해 전달되면, 상위클래스인 바리스타 공장에서 이 레시피를 토대로 음료를 생산하는 생산 공정

### ✔️ 자바스크립트의 팩토리 패턴

### ✔️ 자바의 팩토리 패턴

## 1.1.3 전략 패턴

- 전략 패턴(strategy pattern), 정책 패턴(policy pattern)
    - 객체의 행위를 바꾸고 싶은 경우 ‘직접' 수정하지 않고, 전략이라고 부르는 ‘캡슐화한 알고리즘’을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴
    - 컨텍스트
        - 상황, 맥락, 문맥을 의미. 개발자가 어떠한 작업을 완료하는 데 필요한 모든 관련 정보

### ✔️ 자바의 전략 패턴

### ✔️ passport의 전략 패턴
- passport
    - 전략 패턴을 활용한 라이브러리
    - Node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리
    - 여러가지 ‘전략’을 기반으로 인증할 수 있게 함
        - LocalStrategy 전략 - 서비스 내 가입된 아이디, 비밀번호를 기반으로 인증
        - OAuth 전략 - 페이스북, 네이버 등 다른 서비스를 기반으로 인증

# 1.1.4 옵저버 패턴

- 옵저버 패턴(observer pattern)
    - 주체가 어떤 객체의 상태변화를 관찰하다가, 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버 들에게 변화를 알려주는 디자인 패턴
        - 주체: 객체의 상태 변화를 보고 있는 관찰자
        - 옵저버: 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 ‘추가 변화 사항’이 생기는 객체들
- 옵저버 패턴의 활용 예시
    - 트위터
        - 주체를 ‘팔로우’ 했다면 주체가 포스팅을 올리게 된 경우 알림이 ‘팔로워’에게 감
    - 이벤트 기반 시스템
    - MVC(Model-View-Controller) 패턴
- :자바에서의 옵저버 패턴

### ✔️ 자바스크립트에서의 옵저버 패턴

- 자바스크립트에서 옵저버 패턴은 프록시 객체를 통해 구현 가능
- 프록시 객체
    - 어떠한 대상의 기본적 동작(속성 접근, 할당, 순회, 열거, 합수 호출 등)의 작업을 가로챌 수 있는 객체
    - 자바스크립트에서 프록시 객체는 두 개의 매개변수를 가짐
        - target: 프록시할 대상
        - handler: 프록시 객체의 target 동작을 가로채서 정의할 동작들이 정해져 있는 함수
    - 디자인 패턴 중 하나인 프록시 패턴에 의한 객체(1.1.5에서 후술)
- 프록시 객체를 이용한 옵저버 패턴

### ✔️ Vue.js 3.0에서의 옵저버 패턴

- Vue.js에서 ref나 reactive로 정의하면 해당 값이 변경되었을 때 자동으로 DOM에 있는 값이 변경됨
- 이는 프록시 객체를 이용한 옵저버 패턴을 이용해 구현한 것임

## 1.1.5 프록시 패턴과 프록시 서버

- 프록시 패턴(proxy pattern)
    - 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴
    - 이를 통해 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용함
    - 프록시 객체로 쓰이기도 하지만 프록시 서버로도 활용됨
- 프록시 서버에서의 캐싱
    - 캐시 안에 정보를 담아두고, 캐시 안에 있는 정보를 요구하는 요청에 대해, (원격 서버에 요청하지 않고)캐시 안에 있는 데이터를 활용하는 것을 일컬음
    - 장점 - 불필요하게 외부와 연결하지 않으므로 트래픽을 줄일 수 있음
- 프록시 서버(proxy server)
    - 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접근할 수 있게 해주는 컴퓨터 시스템이나 응용프로그램
    - nginx
        - 주로 Node.js 서버 앞단의 프록시 서버로 활용됨
            - 이를 통해 익명 사용자의 직접적인 서버로의 접근을 차단하고, 간접적으로 한 단게를 더 거침으로써 보안성을 강화할 수 있음
        - 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버
    - CloudFlare
        - 전세계적으로 분산된 서버가 있고, 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스
            - CDN(Content Delivery Network): 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크. (이를 통해 사용자가 웹 서버로부터 콘텐츠를 다운로드하는 시간을 줄일 수 있음)
            - 장점
                - DDOS 공격 방어
                    - DDOS는 짧은시간동안 네트워크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 사이버 공격임.
                    - CloudFlare는 의심스러운 트래픽, 시스템을 통해 오는 트래픽을 자동으로 차단함으로써, 소규모 DDOS 공격은 쉽게 막아냄
                - HTTPS 구축
                    - 서버에서 HTTPS를 구축할 때 인증서를 기반으로 구축할 수도 있음
                    - 하지만 CloudFlare를 사용하면 별도의 인증서 없이 손쉽게 HTTPS 구축 가능
    - CORS와 프런트엔드의 프록시 서버
        - 오리진
            - 프로토콜과 호스트 이름, 포트의 조합
            - 예를 들어 [https://kundol.com:12010/test라는](https://kundol.com:12010/test라는) 주소에서 오리진은 https://kundol.com:12010을 뜻함
        - CORS(Cross-Origin Resource Sharing)
            - 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘
            - 프론트엔드 개발시 프론트엔드 서버를 만들어 백엔드 서버와 통신할 때 주로 CORS 에러를 마주치는데, 이를 해결하기 위해 프런트엔드에서 프록시 서버를 만들기도 함.
            - 예를 들어 프론트엔드에서는 3000포트로 테스팅을 하는데, 백엔드 서버는 12010이면 포트 번호가 다르므로 CORS 에러가 남. 이때 프록시 서버를 둬서 프론트엔드 서버에서 요청되는 오리진을 12010으로 바꾸는 것임.
                - 참고! - 127.0.0.1은 루프백 IP. 본인 PC의 IP를 뜻함. localhost나 127.0.0.1을 입력하면 DNS를 타지 않고 바로 본인 PC로 연결됨

## 1.1.6 이터레이터 패턴

- 이터레이터 패턴(iterator pattern)
    - 이터레이터를 사용하여 컬렉션(collection)의 요소들에 접근하는 디자인 패턴
    - 자료형의 구조와는 상관 없이 이터레이터라는 하나의 인터페이스로 순회가 가능함

### ✔️ 자바스크립트에서의 이터레이터 패턴

- 서로 다른 자료구조인 set과 map에서도, 같은 이터레이터 프로토콜을 통해 순회할 수 있음
    - 이터레이터 프로토콜 : 이터러블한 객체들을 순회할 때 쓰이는 규칙
    - 이터러블한 객체: 반복 가능한 객체로 배열을 일반화한 객체


## 1.1.7 노출모듈 패턴

- 노출모듈 패턴(revealing module pattern)
    - 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴
    - 자바스크립트는 접근제어자가 존재하지 않고 전역 범위에서 스크립트가 실행 됨 → 그러므로 노출 모듈 패턴을 통해 private, public 접근 제어자를 구현하기도 함.(예: CommonJS 모듈 방식)
    - 즉시 실행 함수
        - 함수를 정의하자마자 바로 호출하는 함수.
        - 초기화 코드, 라이브러리 내 전역 변수의 충돌 방지 등에 사용함.


## 1.1.8 MVC 패턴

- MVC 패턴
    - 모델, 뷰, 컨트롤러로 이루어진 디자인 패턴
    - 애플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있게 함
    - 장단점
        - 재사용성, 확장성 용이
        - 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해짐
    - 모델(Model)
        - 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 뜻함
    - 뷰(view)
        - 사용자 인터페이스 요소(예: textarea, checkbox, inputbox ….)
        - 모델을 기반으로 사용자가 볼 수 있는 화면
        - 모델이 가지고 있는 정보를 따로 저장하지 않아야 하며, 단순히 사각형 모양 등 화면에 표시하는 정보만 가지고 있어야 함.
        - 변경이 일어나면 컨트롤러에 이를 전달해야 함.
    - 컨트롤러(controller)
        - 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할
        - 이벤트 등 메인 로직을 담당
        - 모델과 뷰의 생명주기 관리
        - 모델이나 뷰의 변경 통지를 받으면 이를 해석해 각각의 구성 요소에 해당 내용에 대해 알려줌

### ✔️ React.js - MVC 패턴의 예

- 리액트
    - 유저 인터페이스를 구축하기 위한 라이브러리
    - ‘가상 DOM’을 통해 실제 DOM을 조장하는 것을 추상화하여 성능을 높였음
    - 특징
        - 불변성(immutable)
            - 예를들어 state는 setState를 통해서만 수정이 가능하고, props를 기반으로 해서 만들어지는 컴포넌트인 pureComponent가 있음
        - 단방향 바인딩이 적용되어 있음
        - 자유도가 높음
        - 메타(페이스북)이 운영하며 넷플릭스, 트위터, 드롭박스, 우버, 페이팔, 마이크로소프트 등에서 사용됨


## 1.1.9 MVP 패턴

- MVP 패턴
    - MVC 패턴으로부터 파생됨. C에 해당하는 컨트롤러가 프레젠터(presenter)로 교체된 패턴
    - 특징
        - 뷰와 프레젠터가 일대일 관계 → MVC 패턴보다 더 강한 결합을 지님


## 1.1.10 MVVM 패턴

- MVVM 패턴
    - MVC패턴으로부터 파생됨. C에 해당하는 컨트롤러가 뷰모델(view model)로 바뀐 패턴
    - 뷰 모델(view model): 뷰를 더 추상화한 계층
    - 특징
        - MVC 패턴과는 다르게 커맨드와 데이터바인딩을 가짐
            - 커맨드: 여러가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법
            - 데이터바인딩: 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법. 뷰모델을 변경하면 뷰가 변경됨.
        - 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원
        - UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉬움

### ✔️ Vue.js - MVVM 패턴의 예

- Vue.js
    - MVVM 패턴을 가진 대표적인 프레임워크
    - 반응형이 특징
        - 예를들어 watch와 computed 등으로 쉽게 반응형 값들을 구축할 수 있음
    - 함수를 사용하지 않고 값 대입만으로도 변수가 변경됨
    - 양망향 바인딩, html을 토대로 컴포넌트 구축 가능
    - 재사용 가능한 컴포넌트 기반 UI 구축 가능
    - BMW, 구글, 루이비통 등에서 사용